#!/bin/bash

# Скрипт для обновления системы Alt Linux и установки приложений.
# Выполняет epm -y ei и epm -y full-upgrade.
# Позволяет установить git и vscode с ключами -i или --install.

set -e  # Выход при ошибке

# --- Цвета и функции логирования ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
VERY_LIGHT_BLUE='\033[0;36m'
NC='\033[0m' # No Color

log() {
    echo -e "${VERY_LIGHT_BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ОШИБКА]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[УСПЕХ]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[ПРЕДУПРЕЖДЕНИЕ]${NC} $1"
}
# --- Конец секции логирования ---

# --- Основные функции ---
check_root() {
    if [[ $EUID -ne 0 ]]; then
        error "Этот скрипт должен быть запущен с правами root (sudo)"
        exit 1
    fi
}

# Переменная для флага установки
INSTALL_APPS=0

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --install|-i)
                INSTALL_APPS=1
                shift
                ;;
            --help|-h)
                echo "Использование: $0 [ОПЦИИ]"
                echo ""
                echo "Опции:"
                echo "  -i, --install    Установить/обновить git и vscode"
                echo "  -h, --help       Показать эту справку"
                echo ""
                echo "Без опций скрипт только обновляет систему."
                exit 0
                ;;
            *)
                error "Неизвестная опция: $1"
                echo "Используйте '$0 --help' для получения справки"
                exit 1
                ;;
        esac
    done
}

install_applications() {
    local apps_to_install=("$@")
    if [[ ${#apps_to_install[@]} -eq 0 ]]; then
        warning "Список приложений для установки пуст."
        return
    fi

    log "--- Запуск установки приложений: ${apps_to_install[*]} ---"

    # Карта для сопоставления имени пакета и имени команды
    declare -A app_command_map
    app_command_map["git"]="git"
    app_command_map["code"]="code"

    # Карта для сопоставления имени пакета и его отображаемого имени
    declare -A app_display_name_map
    app_display_name_map["git"]="git"
    app_display_name_map["code"]="vscode"

    for package_name in "${apps_to_install[@]}"; do
        local command_name=${app_command_map[$package_name]}
        local display_name=${app_display_name_map[$package_name]}
        # Если для пакета нет карты, считаем, что имя команды и отображаемое имя совпадают с именем пакета
        if [[ -z "$command_name" ]]; then
            command_name=$package_name
        fi
        if [[ -z "$display_name" ]]; then
            display_name=$package_name
        fi

        log "--- Обработка '$display_name' ---"
        if command -v "$command_name" &> /dev/null; then
            log "Приложение '$display_name' уже установлено. Обновление..."
        else
            log "Приложение '$display_name' не найдено. Установка..."
        fi

        if epm -y install "$package_name"; then
            success "'$display_name' успешно установлен/обновлен."
        else
            # С set -e скрипт завершится здесь, но добавим сообщение для ясности
            error "Не удалось установить/обновить '$display_name'."
            exit 1
        fi
    done

    log "--- Установка приложений завершена ---"
}

update_indexes() {
    log "Обновление индексов пакетов (epm -y ei)..."
    epm -y ei
    success "Индексы пакетов успешно обновлены."
}

perform_full_upgrade() {
    log "Полное обновление системы (epm -y full-upgrade)..."
    epm -y full-upgrade
    success "Система успешно обновлена."
}
# --- Конец секции функций ---

# --- Основная логика ---
main() {
    check_root
    parse_args "$@"

    log "Запуск скрипта."

    if [[ ${INSTALL_APPS} -eq 1 ]]; then
        install_applications "git" "code"
    fi

    update_indexes
    perform_full_upgrade

    success "Скрипт успешно завершил работу."
    log "Рекомендуется перезагрузить систему."
}

# Обработка прерывания
trap 'error "Скрипт прерван пользователем"; exit 1' INT TERM

# Запуск
main "$@"